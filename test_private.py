import typing
import unittest
import numpy as np
import random
from divconq import IntelDevice

def generate_grid(m, n):
    random.seed(9001)
    x = 0
    grid = [[0 for j in range(n)] for i in range(m)]
    for i in range(m):
        for j in range(n):
            grid[i][j] = x
            x += 1 + random.randint(0, 1)
    return grid



class TestIntelDevice(unittest.TestCase):

    def test_big_grid(self):
        a = np.array(
            generate_grid(100, 100)
        )
        c_shift = 2


        raw_locations = [f"l{i}" for i in range(len(a) * len(a[0]))]
        raw_codes = [str(x) for x in a.reshape(-1)]


        enc_locations = []
        for i in raw_locations:
            bit_string = ""
            for letter in i:
                bit_string += '{0:b} '.format(ord(letter) + c_shift)
            enc_locations.append(bit_string[:-1])


        enc_codes = []
        for i in raw_codes:
            bit_string = ""
            for letter in i:
                bit_string += '{0:b} '.format(ord(letter) + c_shift)
            enc_codes.append(bit_string[:-1])


        ob = IntelDevice(len(a[0]), len(a), enc_locations, enc_codes, c_shift)
        ob.fill_coordinate_to_loc()
        ob.fill_loc_grid()

        print(ob.loc_grid)

        
        for vid, v in enumerate(a.reshape(-1)):
            result = ob.start_search(v)
            self.assertEqual(result, enc_locations[vid])


    def test_one_row_grid(self):
        a = np.array([
            [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
        ])
        c_shift = 2


        raw_locations = [f"l{i}" for i in range(len(a) * len(a[0]))]
        raw_codes = [str(x) for x in a.reshape(-1)]


        enc_locations = []
        for i in raw_locations:
            bit_string = ""
            for letter in i:
                bit_string += '{0:b} '.format(ord(letter) + c_shift)
            enc_locations.append(bit_string[:-1])


        enc_codes = []
        for i in raw_codes:
            bit_string = ""
            for letter in i:
                bit_string += '{0:b} '.format(ord(letter) + c_shift)
            enc_codes.append(bit_string[:-1])


        ob = IntelDevice(len(a[0]), len(a), enc_locations, enc_codes, c_shift)
        ob.fill_coordinate_to_loc()
        ob.fill_loc_grid()

        print(ob.loc_grid)

        
        for vid, v in enumerate(a.reshape(-1)):
            result = ob.start_search(v)
            self.assertEqual(result, enc_locations[vid])

    def test_encode_message(self):
        # testing with special characters, emoji's, multiline string, negative ceaser
        ob = IntelDevice(3,5,[],[],-4)
        queries = [
            "Ã¦Ã†Ã¸Ã˜", 
            "ğŸ˜€ ğŸ˜ƒ ğŸ˜„ ğŸ˜ ğŸ˜† ğŸ˜… ğŸ˜‚ ğŸ¤£ ğŸ¥² ğŸ¥¹ ğŸ˜Š ğŸ˜‡ ğŸ™‚ ğŸ™ƒ ğŸ˜‰ ğŸ˜Œ ğŸ˜ ğŸ¥° ğŸ˜˜ ğŸ˜— ğŸ˜™ ğŸ˜š ğŸ˜‹ ğŸ˜› ğŸ˜ ğŸ˜œ ğŸ¤ª ğŸ¤¨ ğŸ§ ğŸ¤“ ğŸ˜ ğŸ¥¸ ğŸ¤© ğŸ¥³ ğŸ˜ ğŸ˜’ ğŸ˜ ğŸ˜” ğŸ˜Ÿ ğŸ˜• ğŸ™ â˜¹ï¸ ğŸ˜£ ğŸ˜– ğŸ˜« ğŸ˜© ğŸ¥º ğŸ˜¢ ğŸ˜­ ğŸ˜®â€ğŸ’¨ ğŸ˜¤ ğŸ˜  ğŸ˜¡ ğŸ¤¬ ğŸ¤¯ ğŸ˜³ ğŸ¥µ ğŸ¥¶ ğŸ˜± ğŸ˜¨ ğŸ˜° ğŸ˜¥ ğŸ˜“ ğŸ«£ ğŸ¤— ğŸ«¡ ğŸ¤” ğŸ«¢ ğŸ¤­ ğŸ¤« ğŸ¤¥ ğŸ˜¶ ğŸ˜¶â€ğŸŒ«ï¸ ğŸ˜ ğŸ˜‘ ", 
            """Lorem ipsum dolor sit amet consectetur adipisicing elit. Maxime mollitia,
molestiae quas vel sint commodi repudiandae consequuntur voluptatum laborum
numquam blanditiis harum quisquam eius sed odit fugiat iusto fuga praesentium
optio, eaque rerum! Provident similique accusantium nemo autem. Veritatis
obcaecati tenetur iure eius earum ut molestias architecto voluptate aliquam
nihil, eveniet aliquid culpa officia aut! Impedit sit sunt quaerat, odit,
tenetur error, harum nesciunt ipsum debitis quas aliquid. Reprehenderit"""]
        
        answers =[
            "11100010 11000010 11110100 11010100",
            "11111010111111100 11100 11111010111111111 11100 11111011000000000 11100 11111010111111101 11100 11111011000000010 11100 11111011000000001 11100 11111010111111110 11100 11111100100011111 11100 11111100101101110 11100 11111100101110101 11100 11111011000000110 11100 11111011000000011 11100 11111011000111110 11100 11111011000111111 11100 11111011000000101 11100 11111011000001000 11100 11111011000001001 11100 11111100101101100 11100 11111011000010100 11100 11111011000010011 11100 11111011000010101 11100 11111011000010110 11100 11111011000000111 11100 11111011000010111 11100 11111011000011001 11100 11111011000011000 11100 11111100100100110 11100 11111100100100100 11100 11111100111001100 11100 11111100100001111 11100 11111011000001010 11100 11111100101110100 11100 11111100100100101 11100 11111100101101111 11100 11111011000001011 11100 11111011000001110 11100 11111011000011010 11100 11111011000010000 11100 11111011000011011 11100 11111011000010001 11100 11111011000111101 11100 10011000110101 1111111000001011 11100 11111011000011111 11100 11111011000010010 11100 11111011000100111 11100 11111011000100101 11100 11111100101110110 11100 11111011000011110 11100 11111011000101001 11100 11111011000101010 10000000001001 11111010010100100 11100 11111011000100000 11100 11111011000011100 11100 11111011000011101 11100 11111100100101000 11100 11111100100101011 11100 11111011000101111 11100 11111100101110001 11100 11111100101110010 11100 11111011000101101 11100 11111011000100100 11100 11111011000101100 11100 11111011000100001 11100 11111011000001111 11100 11111101011011111 11100 11111100100010011 11100 11111101011011101 11100 11111100100010000 11100 11111101011011110 11100 11111100100101001 11100 11111100100100111 11100 11111100100100001 11100 11111011000110010 11100 11111011000110010 10000000001001 11111001100100111 1111111000001011 11100 11111011000001100 11100 11111011000001101 11100",
            "1001000 1101011 1101110 1100001 1101001 11100 1100101 1101100 1101111 1110001 1101001 11100 1100000 1101011 1101000 1101011 1101110 11100 1101111 1100101 1110000 11100 1011101 1101001 1100001 1110000 11100 1011111 1101011 1101010 1101111 1100001 1011111 1110000 1100001 1110000 1110001 1101110 11100 1011101 1100000 1100101 1101100 1100101 1101111 1100101 1011111 1100101 1101010 1100011 11100 1100001 1101000 1100101 1110000 101010 11100 1001001 1011101 1110100 1100101 1101001 1100001 11100 1101001 1101011 1101000 1101000 1100101 1110000 1100101 1011101 101000 110 1101001 1101011 1101000 1100001 1101111 1110000 1100101 1011101 1100001 11100 1101101 1110001 1011101 1101111 11100 1110010 1100001 1101000 11100 1101111 1100101 1101010 1110000 11100 1011111 1101011 1101001 1101001 1101011 1100000 1100101 11100 1101110 1100001 1101100 1110001 1100000 1100101 1011101 1101010 1100000 1011101 1100001 11100 1011111 1101011 1101010 1101111 1100001 1101101 1110001 1110001 1101010 1110000 1110001 1101110 11100 1110010 1101011 1101000 1110001 1101100 1110000 1011101 1110000 1110001 1101001 11100 1101000 1011101 1011110 1101011 1101110 1110001 1101001 110 1101010 1110001 1101001 1101101 1110001 1011101 1101001 11100 1011110 1101000 1011101 1101010 1100000 1100101 1110000 1100101 1100101 1101111 11100 1100100 1011101 1101110 1110001 1101001 11100 1101101 1110001 1100101 1101111 1101101 1110001 1011101 1101001 11100 1100001 1100101 1110001 1101111 11100 1101111 1100001 1100000 11100 1101011 1100000 1100101 1110000 11100 1100010 1110001 1100011 1100101 1011101 1110000 11100 1100101 1110001 1101111 1110000 1101011 11100 1100010 1110001 1100011 1011101 11100 1101100 1101110 1011101 1100001 1101111 1100001 1101010 1110000 1100101 1110001 1101001 110 1101011 1101100 1110000 1100101 1101011 101000 11100 1100001 1011101 1101101 1110001 1100001 11100 1101110 1100001 1101110 1110001 1101001 11101 11100 1001100 1101110 1101011 1110010 1100101 1100000 1100001 1101010 1110000 11100 1101111 1100101 1101001 1100101 1101000 1100101 1101101 1110001 1100001 11100 1011101 1011111 1011111 1110001 1101111 1011101 1101010 1110000 1100101 1110001 1101001 11100 1101010 1100001 1101001 1101011 11100 1011101 1110001 1110000 1100001 1101001 101010 11100 1010010 1100001 1101110 1100101 1110000 1011101 1110000 1100101 1101111 110 1101011 1011110 1011111 1011101 1100001 1011111 1011101 1110000 1100101 11100 1110000 1100001 1101010 1100001 1110000 1110001 1101110 11100 1100101 1110001 1101110 1100001 11100 1100001 1100101 1110001 1101111 11100 1100001 1011101 1101110 1110001 1101001 11100 1110001 1110000 11100 1101001 1101011 1101000 1100001 1101111 1110000 1100101 1011101 1101111 11100 1011101 1101110 1011111 1100100 1100101 1110000 1100001 1011111 1110000 1101011 11100 1110010 1101011 1101000 1110001 1101100 1110000 1011101 1110000 1100001 11100 1011101 1101000 1100101 1101101 1110001 1011101 1101001 110 1101010 1100101 1100100 1100101 1101000 101000 11100 1100001 1110010 1100001 1101010 1100101 1100001 1110000 11100 1011101 1101000 1100101 1101101 1110001 1100101 1100000 11100 1011111 1110001 1101000 1101100 1011101 11100 1101011 1100010 1100010 1100101 1011111 1100101 1011101 11100 1011101 1110001 1110000 11101 11100 1000101 1101001 1101100 1100001 1100000 1100101 1110000 11100 1101111 1100101 1110000 11100 1101111 1110001 1101010 1110000 11100 1101101 1110001 1011101 1100001 1101110 1011101 1110000 101000 11100 1101011 1100000 1100101 1110000 101000 110 1110000 1100001 1101010 1100001 1110000 1110001 1101110 11100 1100001 1101110 1101110 1101011 1101110 101000 11100 1100100 1011101 1101110 1110001 1101001 11100 1101010 1100001 1101111 1011111 1100101 1110001 1101010 1110000 11100 1100101 1101100 1101111 1110001 1101001 11100 1100000 1100001 1011110 1100101 1110000 1100101 1101111 11100 1101101 1110001 1011101 1101111 11100 1011101 1101000 1100101 1101101 1110001 1100101 1100000 101010 11100 1001110 1100001 1101100 1101110 1100001 1100100 1100001 1101010 1100000 1100001 1101110 1100101 1110000"
        ] 
        
        for query, answer in zip(queries, answers):
            self.assertEqual(ob.encode_message(query),answer)
